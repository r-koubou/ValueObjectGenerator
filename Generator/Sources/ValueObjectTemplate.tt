<#@ template language="C#" visibility="internal" linePragmas="false" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp.Syntax" #>
//
// Generated by ValueObjectGenerator
// DO NOT EDIT THIS FILE
//
using System;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

<#
    ValueName = ValueName.Replace( "\"", "" );
    var declarationType = DeclarationSyntax.Keyword;

    var requireNotEmpty = NotEmpty;
    var requireNonNegative = NotNegative;
    var requireMinMax = !string.IsNullOrEmpty( Min ) && !string.IsNullOrEmpty( Max );
    var requireValidateMethod =
        !ValueOption.HasFlag( ValueOption.NonValidating ) &&
        !requireNotEmpty &&
        !requireNonNegative &&
        !requireMinMax;

    var isClass = DeclarationSyntax is ClassDeclarationSyntax;
    var isStruct = DeclarationSyntax is StructDeclarationSyntax;

#>
<# if( !string.IsNullOrEmpty( Namespace ) ) { #>
namespace <#= Namespace #>
{
<# } #>
    public partial <#= declarationType #> <#= Name #> : IEquatable<<#= Name #>><#= ValueOption.HasFlag( ValueOption.Comparable ) ? $", IComparable<{Name}>" : "" #>
    {
        public <#= BaseTypeName #> <#= ValueName #> { get; }
<# /* Min-Max Variable */ #>
<# if( requireMinMax ) { #>
        public static readonly <#= Name #> Min = new <#= Name #>( <#= Min #> );
        public static readonly <#= Name #> Max = new <#= Name #>( <#= Max #> );
<# } #>

        public <#= Name #>( <#= BaseTypeName #> value )
        {
<# /* Non-Empty */ #>
<# if( requireNotEmpty ) { #>
<# if( BaseTypeName == "string" ) { #>
            if( string.IsNullOrEmpty( value )<#= !ExcludeWhiteSpace ? " || value.Trim().Length == 0" : "" #> )
            {
                throw new ArgumentException( $"(<#= Name #>) value is empty" );
            }
<# } else { #>
            if( !value.Any() )
            {
                throw new ArgumentException( $"(<#= Name #>) value is empty" );
            }
<# } #>
            <#= ValueName #> = value;
<# /* Non-Negative */ #>
<# } else if( requireNonNegative ) { #>
            if( value < 0 )
            {
                throw new ArgumentException( $"(<#= Name #>) value is negative {value}" );
            }
            <#= ValueName #> = value;
<# /* Min, Max */ #>
<# } else if( requireMinMax ) { #>
            if( value < (<#= Min #>) || value > (<#= Max #>) )
            {
                throw new ArgumentOutOfRangeException( $"<#= Name #> Out of range : {value} (range:<#= Min #> < <#= Max #>)" );
            }
            <#= ValueName #> = value;
<# /* No Validation */ #>
<# } else if( !requireValidateMethod ) { #>
            <#= ValueName #> = value;
<# } else { #>
            <#= ValueName #> = Validate( value );
<# } #>
        }

<# /* Validate method */ #>
<# if( requireValidateMethod ) { #>
        private static partial <#= BaseTypeName #> Validate( <#= BaseTypeName #> value );
<# } #>

<# /* ToString */ #>
<# if( !ValueOption.HasFlag( ValueOption.ToString ) ) { #>
        //
        // Default ToString()
        //
        public override string ToString()
        {
            return <#= ValueName #>.ToString() ?? "";
        }
<# } else { #>
        //
        // Custom ToString()
        //
        private partial string ToStringImpl();

        public override string ToString()
        {
            return ToStringImpl();
        }
<# } #>

        //----------------------------------------------------------------------
        // Equality
        //----------------------------------------------------------------------
        public bool Equals( <#= isClass ? "[AllowNull] " : "" #><#= Name #> other )
        {
<# if( isClass ) { #>
            if( ReferenceEquals( null, other ) )
            {
                return false;
            }

            if( ReferenceEquals( this, other ) )
            {
                return true;
            }
            return <#= ValueName #> == other.<#= ValueName #>;
<# } else if( isStruct ) { #>
            return Equals( <#= ValueName #>, other.<#= ValueName #> );
<# } #>
        }

        public override bool Equals( [AllowNull] object obj )
        {
<# if( isClass ) { #>
            if( ReferenceEquals( null, obj ) )
            {
                return false;
            }

            if( ReferenceEquals( this, obj ) )
            {
                return true;
            }

            if( obj.GetType() != this.GetType() )
            {
                return false;
            }

            return Equals( (<#= Name #>)obj );
<# } else if( isStruct ) { #>
            return obj is <#= Name #> other && Equals( other );
<# } #>
        }

        // HashCode
        public override int GetHashCode() => <#= ValueName #>.GetHashCode();

        // Operator ==, !=
        public static bool operator ==( <#= Name #> a, <#= Name #> b )
        {
<# if( isClass ) { #>
            if( ReferenceEquals( a, b ) )
            {
                return true;
            }

            return a?.Equals( b ) ?? ReferenceEquals( null, b );
<# } else if( isStruct ) { #>
            return a.Equals( b );
<# } #>
        }

        public static bool operator !=( <#= Name #> a, <#= Name #> b )
        {
            return !( a == b );
        }

<# if( ValueOption.HasFlag( ValueOption.Explicit ) ) { #>
        //----------------------------------------------------------------------
        // Explicit
        //----------------------------------------------------------------------
        public static explicit operator <#= BaseTypeName #>( <#= Name #> x )
        {
            return x.<#= ValueName #>;
        }

        public static explicit operator <#= Name #>( <#= BaseTypeName #> value )
        {
            return new <#= Name #>( value );
        }
<# } else if( ValueOption.HasFlag( ValueOption.Implicit ) ) { #>
        //----------------------------------------------------------------------
        // Implicit
        //----------------------------------------------------------------------
        public static implicit operator <#= BaseTypeName #>( <#= Name #> x )
        {
            return x.<#= ValueName #>;
        }

        public static implicit operator <#= Name #>( <#= BaseTypeName #> value )
        {
            return new <#= Name #>( value );
        }
<# } #>

<# if( ValueOption.HasFlag( ValueOption.Comparable ) ) { #>
        //----------------------------------------------------------------------
        // Comparable
        //----------------------------------------------------------------------
        public int CompareTo( <#= Name #> other )
        {
            if( ReferenceEquals( this, other ) )
            {
                return 0;
            }

            if( ReferenceEquals( null, other ) )
            {
                return 1;
            }

            return <#= ValueName #>.CompareTo( other.<#= ValueName #> );
        }
<# } #>

    }

<# if( !string.IsNullOrEmpty( Namespace ) ) { #>
}
<# } #>
